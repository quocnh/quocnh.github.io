<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://quocnh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://quocnh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-26T12:59:06+00:00</updated><id>https://quocnh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">1207. Unique Number of Occurrences</title><link href="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/" rel="alternate" type="text/html" title="1207. Unique Number of Occurrences"/><published>2024-12-26T00:00:00+00:00</published><updated>2024-12-26T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/"><![CDATA[<p>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.</p> <p>Example 1:</p> <p>Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</p> <p>Example 2:</p> <p>Input: arr = [1,2] Output: false</p> <p>Example 3:</p> <p>Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true</p> <h2 id="set-and-hashmap">set and hashmap</h2> <ul> <li>Time complexity: O(N)</li> <li>Space complexity: O(N),</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uniqueOccurrences</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type arr: List[int]
        :rtype: bool
        </span><span class="sh">"""</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># find number of currences
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Check the same # of currences or not
</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.]]></summary></entry><entry><title type="html">437. Path Sum III</title><link href="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/" rel="alternate" type="text/html" title="437. Path Sum III"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Path%20Sum-III</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p> <p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p> <p>Example 1:</p> <p>Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3</p> <p>Explanation: The paths that sum to 8 are shown. Example 2:</p> <p>Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3</p> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n) , n: number of nodes</li> <li>Space complexity: O(h), h: height of tree</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># # Definition for a binary tree node.
# # class TreeNode(object):
# #     def __init__(self, val=0, left=None, right=None):
# #         self.val = val
# #         self.left = left
# #         self.right = right
# class Solution(object):
#     def pathSum(self, root, targetSum):
#         """
#         :type root: Optional[TreeNode]
#         :type targetSum: int
#         :rtype: int
#         """
#         self.total = 0
#         def helper(node, cur):
#             if not node:
#                 return
</span>            
<span class="c1">#             helper(node.left, cur + node.val)
#             helper(node.right, cur + node.val)
#             if node.val + cur == targetSum:
#                 self.total +=1
#         def dfs(node):
#             if not node:
#                 return
#             count = helper(node, 0)
#             dfs(node.left)
#             dfs(node.right)
</span>            
<span class="c1">#         dfs(root)
#         return self.total
</span>        

<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="c1"># Update the current sum
</span>            <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            
            <span class="c1"># Check if there's a prefix sum such that currentSum - targetSum exists
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span><span class="p">]</span>
            
            <span class="c1"># Update the prefixSums map
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="c1"># Recursively visit left and right subtrees
</span>            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            
            <span class="c1"># Backtrack: remove the currentSum from prefixSums
</span>            <span class="k">if</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Initialize variables
</span>        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use a list to allow mutation
</span>        <span class="n">prefixSums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Base case for when currentSum == targetSum
</span>        
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.]]></summary></entry><entry><title type="html">560. Subarray Sum Equals K</title><link href="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/" rel="alternate" type="text/html" title="560. Subarray Sum Equals K"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">The</span> <span class="n">problem</span> <span class="sh">"</span><span class="s">560. Subarray Sum Equals K</span><span class="sh">"</span> <span class="ow">is</span> <span class="n">about</span> <span class="n">finding</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">a</span> <span class="n">given</span> <span class="n">array</span> <span class="n">whose</span> <span class="n">elements</span> <span class="nb">sum</span> <span class="n">up</span> <span class="n">to</span> <span class="n">a</span> <span class="n">given</span> <span class="n">integer</span> 
<span class="n">ùëò</span>

<span class="n">Understanding</span> <span class="k">with</span> <span class="n">Examples</span>
<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span>

<span class="n">The</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">nums</span> <span class="n">are</span><span class="p">:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">‚Üí</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">‚Üí</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">‚Üí</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">‚Üí</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">‚Üí</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="n">There</span> <span class="n">are</span> <span class="mi">2</span> <span class="n">subarrays</span> <span class="n">whose</span> <span class="nb">sum</span> <span class="n">equals</span> 
<span class="n">ùëò</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">runningSum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Initialize with {0: 1}
</span>    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">runningSum</span> <span class="o">+=</span> <span class="n">num</span>
        
        <span class="c1"># Check if (runningSum - k) exists in the hashmap
</span>        <span class="k">if</span> <span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Update the hashmap with the current runningSum
</span>        <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">runningSum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">count</span>   
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python The problem ‚Äú560. Subarray Sum Equals K‚Äù is about finding all the contiguous subarrays of a given array whose elements sum up to a given integer ùëò]]></summary></entry><entry><title type="html">2130. Maximum Twin Sum of a Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/" rel="alternate" type="text/html" title="2130. Maximum Twin Sum of a Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">n</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">size</span> <span class="n">n</span><span class="p">,</span> <span class="n">where</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">even</span><span class="p">,</span> <span class="n">the</span> <span class="n">ith</span> <span class="nf">node </span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="n">indexed</span><span class="p">)</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">known</span> <span class="k">as</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="nf">the </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="n">th</span> <span class="n">node</span><span class="p">,</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span>

<span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">then</span> <span class="n">node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">and</span> <span class="n">node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mf">2.</span> <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">only</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">4.</span>

<span class="n">The</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="ow">is</span> <span class="n">defined</span> <span class="k">as</span> <span class="n">the</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">its</span> <span class="n">twin</span><span class="p">.</span>

<span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="k">with</span> <span class="n">even</span> <span class="n">length</span><span class="p">,</span> <span class="k">return</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>

 

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">6</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">Nodes</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="n">are</span> <span class="n">the</span> <span class="n">twins</span> <span class="n">of</span> <span class="n">nodes</span> <span class="mi">3</span> <span class="ow">and</span> <span class="mi">2</span><span class="p">,</span> <span class="n">respectively</span><span class="p">.</span> <span class="n">All</span> <span class="n">have</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mf">6.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">no</span> <span class="n">other</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="mf">6.</span> 

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">7</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">The</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="n">present</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">are</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mf">4.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="nf">max</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mf">7.</span> 

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">100000</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">100001</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">There</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">one</span> <span class="n">node</span> <span class="k">with</span> <span class="n">a</span> <span class="n">twin</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">having</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">100000</span> <span class="o">=</span> <span class="mf">100001.</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">even</span> <span class="n">integer</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">105</span><span class="p">].</span>
    <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">105</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <p>Approach:</p> <p>Steps:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find the Middle of the Linked List:
    Use the fast and slow pointer technique to locate the midpoint of the list efficiently.

Reverse the Second Half of the List:
    Reverse the second half of the linked list to facilitate pairing the twin nodes.

Calculate Twin Sums:
    Traverse both halves simultaneously (one from the start and the other from the reversed list) to compute twin sums.

Find the Maximum Twin Sum:
    Keep track of the maximum twin sum encountered during the traversal.
</code></pre></div></div> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pairSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type head: Optional[ListNode]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># find the middle of head
</span>        <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>

        <span class="c1"># reverse the second half
</span>        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">while</span> <span class="n">slow</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">slow</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="c1"># interate 2 linked list and compute sum
</span>        <span class="n">max_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span>
        <span class="k">while</span> <span class="n">second</span><span class="p">:</span>
            <span class="n">max_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">max_sum</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given n a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1.]]></summary></entry><entry><title type="html">206. Reverse Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/" rel="alternate" type="text/html" title="206. Reverse Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">singly</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">,</span> <span class="n">reverse</span> <span class="n">the</span> <span class="nb">list</span><span class="p">,</span> <span class="ow">and</span> <span class="k">return</span> <span class="n">the</span> <span class="nb">reversed</span> <span class="nb">list</span><span class="p">.</span>

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[]</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">].</span>
    <span class="o">-</span><span class="mi">5000</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">5000</span>

 

<span class="n">Follow</span> <span class="n">up</span><span class="p">:</span> <span class="n">A</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">can</span> <span class="n">be</span> <span class="nb">reversed</span> <span class="n">either</span> <span class="n">iteratively</span> <span class="ow">or</span> <span class="n">recursively</span><span class="p">.</span> <span class="n">Could</span> <span class="n">you</span> <span class="n">implement</span> <span class="n">both</span><span class="err">?</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1) <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
      <span class="sh">"""</span><span class="s">
      :type head: Optional[ListNode]
      :rtype: Optional[ListNode]
      </span><span class="sh">"""</span>
      <span class="c1"># 1 -&gt; 2 -&gt; 3 -&gt; 4 - &gt; 5 -&gt; None
</span>      <span class="c1"># Use 2 pointers
</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>

      <span class="k">while</span> <span class="n">current</span><span class="p">:</span> <span class="c1"># while current is still not None
</span>          <span class="c1"># swap the prev and current nodes
</span>          <span class="n">next_node</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
          <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
          <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
          <span class="n">current</span> <span class="o">=</span> <span class="n">next_node</span>
            
      <span class="k">return</span> <span class="n">prev</span> <span class="c1"># new head
</span></code></pre></div> </div> <h2 id="using-stack">Using Stack</h2> </li> </ul>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given the head of a singly linked list, reverse the list, and return the reversed list.]]></summary></entry><entry><title type="html">872. Leaf-Similar Trees</title><link href="https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees/" rel="alternate" type="text/html" title="872. Leaf-Similar Trees"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">The</span> <span class="n">problem</span> <span class="sh">"</span><span class="s">872. Leaf-Similar Trees</span><span class="sh">"</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">LeetCode</span> <span class="n">problem</span> <span class="n">that</span> <span class="n">asks</span> <span class="n">you</span> <span class="n">to</span> <span class="n">determine</span> <span class="k">if</span> <span class="n">two</span> <span class="n">binary</span> <span class="n">trees</span> <span class="n">are</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span><span class="p">.</span> <span class="n">Two</span> <span class="n">trees</span> <span class="n">are</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span> <span class="k">if</span> <span class="n">their</span> <span class="n">leaf</span> <span class="n">values</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">when</span> <span class="n">traversed</span> <span class="k">from</span> <span class="n">left</span> <span class="n">to</span> <span class="n">right</span><span class="p">.</span>

<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">problem</span> <span class="n">breakdown</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">solution</span><span class="p">:</span>

<span class="n">Problem</span> <span class="n">Statement</span>

<span class="n">Consider</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">leaves</span> <span class="n">of</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">tree</span><span class="p">.</span> <span class="n">A</span> <span class="n">leaf</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">node</span> <span class="k">with</span> <span class="n">no</span> <span class="n">children</span><span class="p">.</span> <span class="n">A</span> <span class="n">binary</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">considered</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span> <span class="k">if</span> <span class="n">its</span> <span class="n">leaf</span> <span class="n">values</span><span class="p">,</span> <span class="n">when</span> <span class="n">visited</span> <span class="k">from</span> <span class="n">left</span> <span class="n">to</span> <span class="n">right</span><span class="p">,</span> <span class="n">are</span> <span class="n">identical</span> <span class="n">to</span> <span class="n">another</span> <span class="n">binary</span> <span class="n">tree</span><span class="sh">'</span><span class="s">s leaf values.

Given the roots of two binary trees root1 and root2, return true if and only if the two trees are leaf-similar.

root1 = [3,5,1,6,2,9,8,null,null,7,4]
root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]

return True
</span></code></pre></div></div> <h2 id="dfs">DFS</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(a + b) ```python <h1 id="definition-for-a-binary-tree-node">Definition for a binary tree node.</h1> <h1 id="class-treenodeobject">class TreeNode(object):</h1> <h1 id="def-initself-val0-leftnone-rightnone">def <strong>init</strong>(self, val=0, left=None, right=None):</h1> <h1 id="selfval--val">self.val = val</h1> <h1 id="selfleft--left">self.left = left</h1> <h1 id="selfright--right">self.right = right</h1> <p>class Solution(object): def leafSimilar(self, root1, root2): ‚Äú‚Äù‚Äù :type root1: Optional[TreeNode] :type root2: Optional[TreeNode] :rtype: bool ‚Äú‚Äù‚Äù # DFS def get_leaf_values(node): if not node: return [] if not node.left and not node.right: return [node.val] return get_leaf_values(node.left) + get_leaf_values(node.right) # Get leaf sequences for both trees leaves1 = get_leaf_values(root1) leaves2 = get_leaf_values(root2)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Compare the sequences
  return leaves1 == leaves2
</code></pre></div> </div> </li> </ul> <p>```</p>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python The problem ‚Äú872. Leaf-Similar Trees‚Äù is a LeetCode problem that asks you to determine if two binary trees are leaf-similar. Two trees are leaf-similar if their leaf values are the same when traversed from left to right.]]></summary></entry><entry><title type="html">136. Single Number</title><link href="https://quocnh.github.io/blog/2024/leetcode-Single-Number/" rel="alternate" type="text/html" title="136. Single Number"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Single-Number</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Single-Number/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integers</span> <span class="n">nums</span><span class="p">,</span> <span class="n">every</span> <span class="n">element</span> <span class="n">appears</span> <span class="n">twice</span> <span class="k">except</span> <span class="k">for</span> <span class="n">one</span><span class="p">.</span> <span class="n">Find</span> <span class="n">that</span> <span class="n">single</span> <span class="n">one</span><span class="p">.</span>

<span class="n">You</span> <span class="n">must</span> <span class="n">implement</span> <span class="n">a</span> <span class="n">solution</span> <span class="k">with</span> <span class="n">a</span> <span class="n">linear</span> <span class="n">runtime</span> <span class="n">complexity</span> <span class="ow">and</span> <span class="n">use</span> <span class="n">only</span> <span class="n">constant</span> <span class="n">extra</span> <span class="n">space</span><span class="p">.</span>

 

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div> <h2 id="bitwise">Bitwise</h2> <ul> <li>Time complexity: O(n)</li> <li> <p>Space complexity: O(1) ```python class Solution(object): def singleNumber(self, nums): ‚Äú‚Äù‚Äù :type nums: List[int] :rtype: int ‚Äú‚Äù‚Äù result = 0 for i in nums: result ^= i</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  return result 
</code></pre></div> </div> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Explaination
### XOR Operation and Its Properties
The XOR operator (`^`) works at the bit level and follows these rules:

1. **Same bits produce 0:**
   - `0 ^ 0 = 0`
   - `1 ^ 1 = 0`

2. **Different bits produce 1:**
   - `0 ^ 1 = 1`
   - `1 ^ 0 = 1`

3. **Key Properties for This Problem:**
   - `a ^ a = 0` (Self-canceling: XOR of a number with itself is 0.)
   - `a ^ 0 = a` (XOR of a number with 0 is the number itself.)
   - XOR is **commutative** and **associative**, meaning the order of operations doesn't matter.

---

### Example Walkthrough

#### Input:
```plaintext
nums = [4, 1, 2, 1, 2]
</code></pre></div></div> <p>We initialize <code class="language-plaintext highlighter-rouge">result = 0</code> and process each number in the array using XOR. Let‚Äôs track the changes step by step, highlighting <strong>where numbers cancel each other out.</strong></p> <hr/> <h4 id="step-by-step-process">Step-by-Step Process</h4> <ol> <li><strong>Initial Value:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 0
</code></pre></div> </div> </li> <li><strong>Step 1:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 0 ^ 4 = 4
</code></pre></div> </div> <ul> <li>No cancellation yet because this is the first number.</li> </ul> </li> <li><strong>Step 2:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 4 ^ 1 = 5
</code></pre></div> </div> <ul> <li>Still no cancellation because <code class="language-plaintext highlighter-rouge">1</code> appears for the first time.</li> </ul> </li> <li><strong>Step 3:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 5 ^ 2 = 7
</code></pre></div> </div> <ul> <li>Still no cancellation because <code class="language-plaintext highlighter-rouge">2</code> appears for the first time.</li> </ul> </li> <li><strong>Step 4:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 7 ^ 1 = 6
</code></pre></div> </div> <ul> <li><strong>Here, <code class="language-plaintext highlighter-rouge">1</code> cancels out!</strong> <ul> <li>Why? Because <code class="language-plaintext highlighter-rouge">1</code> appeared earlier in Step 2.</li> <li>When we XOR the same number (<code class="language-plaintext highlighter-rouge">1 ^ 1</code>), it produces <code class="language-plaintext highlighter-rouge">0</code>, effectively removing <code class="language-plaintext highlighter-rouge">1</code> from the result.</li> <li>Binary operation: <ul> <li><code class="language-plaintext highlighter-rouge">7 (111) ^ 1 (001) = 6 (110)</code></li> </ul> </li> </ul> </li> </ul> </li> <li><strong>Step 5:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 6 ^ 2 = 4
</code></pre></div> </div> <ul> <li><strong>Here, <code class="language-plaintext highlighter-rouge">2</code> cancels out!</strong> <ul> <li>Why? Because <code class="language-plaintext highlighter-rouge">2</code> appeared earlier in Step 3.</li> <li>When we XOR the same number (<code class="language-plaintext highlighter-rouge">2 ^ 2</code>), it produces <code class="language-plaintext highlighter-rouge">0</code>, effectively removing <code class="language-plaintext highlighter-rouge">2</code> from the result.</li> <li>Binary operation: <ul> <li><code class="language-plaintext highlighter-rouge">6 (110) ^ 2 (010) = 4 (100)</code></li> </ul> </li> </ul> </li> </ul> </li> </ol> <hr/> <h4 id="final-result">Final Result:</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 4
</code></pre></div></div> <p>At the end, all duplicate numbers (<code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>) have canceled out, and only the single number <code class="language-plaintext highlighter-rouge">4</code> remains.</p> <hr/> <h3 id="key-takeaways">Key Takeaways</h3> <ol> <li><strong>Where Does Self-Canceling Happen?</strong> <ul> <li><strong>Step 4:</strong> The duplicate <code class="language-plaintext highlighter-rouge">1</code> cancels out (<code class="language-plaintext highlighter-rouge">1 ^ 1 = 0</code>).</li> <li><strong>Step 5:</strong> The duplicate <code class="language-plaintext highlighter-rouge">2</code> cancels out (<code class="language-plaintext highlighter-rouge">2 ^ 2 = 0</code>).</li> </ul> </li> <li><strong>Why XOR Works for This Problem:</strong> <ul> <li>Duplicates cancel out because <code class="language-plaintext highlighter-rouge">a ^ a = 0</code>.</li> <li>The XOR of all numbers leaves only the single number that does not have a duplicate.</li> </ul> </li> </ol> <hr/> <h3 id="code-implementation">Code Implementation</h3> <p>Here is the Python implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">^=</span> <span class="n">num</span>  <span class="c1"># XOR all numbers
</span>        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <h4 id="complexity-analysis">Complexity Analysis</h4> <ol> <li><strong>Time Complexity:</strong> <ul> <li>O(N): We iterate through the array once.</li> </ul> </li> <li><strong>Space Complexity:</strong> <ul> <li>O(1): No additional space is used beyond the variable <code class="language-plaintext highlighter-rouge">result</code>.</li> </ul> </li> </ol> <hr/> <h3 id="additional-examples">Additional Examples</h3> <h4 id="example-1">Example 1:</h4> <p><strong>Input:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums = [2, 2, 1]
</code></pre></div></div> <p><strong>Output:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
</code></pre></div></div> <h4 id="example-2">Example 2:</h4> <p><strong>Input:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums = [4, 1, 2, 1, 2]
</code></pre></div></div> <p><strong>Output:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.]]></summary></entry><entry><title type="html">Python Data Structures</title><link href="https://quocnh.github.io/blog/2024/python-data-structure-note/" rel="alternate" type="text/html" title="Python Data Structures"/><published>2024-12-13T00:00:00+00:00</published><updated>2024-12-13T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/python-data-structure-note</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/python-data-structure-note/"><![CDATA[<h2 id="overview">Overview</h2> <table> <thead> <tr> <th>Feature</th> <th><strong>List</strong></th> <th><strong>Set</strong></th> <th><strong>Stack</strong></th> <th><strong>Queue</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Definition</strong></td> <td>Ordered collection of elements, allows duplicates.</td> <td>Unordered collection of unique elements.</td> <td>Last-In-First-Out (LIFO).</td> <td>First-In-First-Out (FIFO).</td> </tr> <tr> <td><strong>Duplicates Allowed</strong></td> <td>‚úÖ Yes</td> <td>‚ùå No</td> <td>‚úÖ Yes</td> <td>‚úÖ Yes</td> </tr> <tr> <td><strong>Ordering</strong></td> <td>‚úÖ Yes</td> <td>‚ùå No</td> <td>‚úÖ Yes</td> <td>‚úÖ Yes</td> </tr> </tbody> </table> <h1 id="python-data-structures-list-set-stack-and-queue">Python Data Structures: List, Set, Stack, and Queue</h1> <ul> <li>List: Ordered, allows duplicates.</li> <li>Set: Unordered, unique elements only.</li> <li>Stack: Last-In-First-Out (LIFO).</li> <li>Queue: First-In-First-Out (FIFO).</li> </ul> <h2 id="1-list">1. LIST</h2> <h3 id="definition">Definition</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Empty list
</span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># List with elements
</span></code></pre></div></div> <h3 id="common-operations">Common Operations</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Add an element, [1, 2, 3, 4, 5]
</span><span class="nf">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Access by index, Output: 1
</span><span class="n">my_list</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Remove by value, [1, 3, 4, 5]
</span><span class="nf">print</span><span class="p">(</span><span class="n">my_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># Slice, Output: [3, 4]
</span>
<span class="c1"># Time Complexities
# Append: O(1)
# Access by Index: O(1)
# Remove (by Value): O(n)
# Slice: O(k)
</span></code></pre></div></div> <h2 id="2-set">2. SET</h2> <h3 id="definition-1">Definition</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>  <span class="c1"># Empty set
</span><span class="n">my_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>  <span class="c1"># Set with elements
</span></code></pre></div></div> <h3 id="common-operations-1">Common Operations</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_set</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Add an element, {1, 2, 3, 4}
</span><span class="n">my_set</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Remove an element, {1, 3, 4}
</span><span class="nf">print</span><span class="p">(</span><span class="mi">3</span> <span class="ow">in</span> <span class="n">my_set</span><span class="p">)</span>  <span class="c1"># Membership check, Output: True
</span>
<span class="c1"># Time Complexities
# Add: O(1)
# Remove: O(1)
# Membership Check: O(1)
</span></code></pre></div></div> <h2 id="3-stack">3. STACK</h2> <h3 id="definition-2">Definition</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_stack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Empty stack
</span><span class="n">my_stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># Stack with elements
</span></code></pre></div></div> <h3 id="common-operations-2">Common Operations</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Push (add), [1, 2, 3, 4]
</span><span class="n">top</span> <span class="o">=</span> <span class="n">my_stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>  <span class="c1"># Pop (remove top), Output: 4, stack becomes [1, 2, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="n">my_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Peek (view top), Output: 3
</span>
<span class="c1"># Time Complexities
# Push: O(1)
# Pop: O(1)
# Peek: O(1)
</span></code></pre></div></div> <h2 id="4-queue">4. QUEUE</h2> <p>from collections import deque</p> <h3 id="definition-3">Definition</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>  <span class="c1"># Empty queue
</span><span class="n">my_queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># Queue with elements
</span></code></pre></div></div> <h3 id="common-operations-3">Common Operations</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Enqueue (add to end), deque([1, 2, 3, 4])
</span><span class="n">front</span> <span class="o">=</span> <span class="n">my_queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>  <span class="c1"># Dequeue (remove from front), Output: 1, queue becomes deque([2, 3, 4])
</span><span class="nf">print</span><span class="p">(</span><span class="n">my_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Peek (view front), Output: 2
</span>
<span class="c1"># Time Complexities
# Enqueue: O(1)
# Dequeue: O(1)
# Peek: O(1)
</span></code></pre></div></div> <h2 id="when-to-use-each">When to Use Each</h2> <ol> <li>List: General-purpose storage, ordered, allows duplicates. Example: Storing items with duplicates, accessing by index.</li> <li>Set: Unique elements, fast membership checks. Example: Removing duplicates, set operations like union.</li> <li>Stack: LIFO operations (Last-In-First-Out). Example: Backtracking, parsing expressions.</li> <li>Queue: FIFO operations (First-In-First-Out). Example: Task scheduling, breadth-first search (BFS).</li> </ol>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Overview]]></summary></entry><entry><title type="html">392. Is Subsequence</title><link href="https://quocnh.github.io/blog/2024/leetcode-is-subsequences/" rel="alternate" type="text/html" title="392. Is Subsequence"/><published>2024-11-30T00:00:00+00:00</published><updated>2024-11-30T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-is-subsequences</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-is-subsequences/"><![CDATA[<p>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</p> <p>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ‚Äúace‚Äù is a subsequence of ‚Äúabcde‚Äù while ‚Äúaec‚Äù is not).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="sh">"</span><span class="s">ahbgdc</span><span class="sh">"</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">true</span>

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="sh">"</span><span class="s">axc</span><span class="sh">"</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="sh">"</span><span class="s">ahbgdc</span><span class="sh">"</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">false</span>
</code></pre></div></div> <h2 id="stack">Stack</h2> <ul> <li>Time complexity: O(n)</li> <li>Memory complexity: O(n)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">isSubsequence</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type s: str
        :type t: str
        :rtype: bool
        </span><span class="sh">"""</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="c1"># if stack is not empty, and compare the last element to i
</span>            <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">stack</span>
</code></pre></div></div> <h2 id="two-pointers">Two pointers</h2> <ul> <li>Time complexity: O(n)</li> <li>Memory complexity: O(1)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">isSubsequence</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># Two pointers for s and t
</span>        
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Match found, move the s pointer
</span>            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Always move the t pointer
</span>        
        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># True if all characters in s are matched
</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given two strings s and t, return true if s is a subsequence of t, or false otherwise.]]></summary></entry><entry><title type="html">334. Increasing Triplet Subsequence</title><link href="https://quocnh.github.io/blog/2024/leetcode-increasing-triplet-subsequence/" rel="alternate" type="text/html" title="334. Increasing Triplet Subsequence"/><published>2024-11-28T00:00:00+00:00</published><updated>2024-11-28T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-increasing-triplet-subsequence</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-increasing-triplet-subsequence/"><![CDATA[<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p> <p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p> <p>You must write an algorithm that runs in O(n) time and without using the division operation.</p> <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">Given</span> <span class="nt">an</span> <span class="nt">integer</span> <span class="nt">array</span> <span class="nt">nums</span><span class="o">,</span> <span class="nt">return</span> <span class="nt">true</span> <span class="nt">if</span> <span class="nt">there</span> <span class="nt">exists</span> <span class="nt">a</span> <span class="nt">triple</span> <span class="nt">of</span> <span class="nt">indices</span> <span class="o">(</span><span class="nt">i</span><span class="o">,</span> <span class="nt">j</span><span class="o">,</span> <span class="nt">k</span><span class="o">)</span> <span class="nt">such</span> <span class="nt">that</span> <span class="nt">i</span> <span class="o">&lt;</span> <span class="nt">j</span> <span class="o">&lt;</span> <span class="nt">k</span> <span class="nt">and</span> <span class="nt">nums</span><span class="o">[</span><span class="nt">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="nt">nums</span><span class="o">[</span><span class="nt">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="nt">nums</span><span class="o">[</span><span class="nt">k</span><span class="o">].</span> <span class="nt">If</span> <span class="nt">no</span> <span class="nt">such</span> <span class="nt">indices</span> <span class="nt">exists</span><span class="o">,</span> <span class="nt">return</span> <span class="nt">false</span><span class="o">.</span>

 

<span class="nt">Example</span> <span class="err">1</span><span class="o">:</span>

<span class="nt">Input</span><span class="o">:</span> <span class="nt">nums</span> <span class="o">=</span> <span class="o">[</span><span class="err">1</span><span class="o">,</span><span class="err">2</span><span class="o">,</span><span class="err">3</span><span class="o">,</span><span class="err">4</span><span class="o">,</span><span class="err">5</span><span class="o">]</span>
<span class="nt">Output</span><span class="o">:</span> <span class="nt">true</span>
<span class="nt">Explanation</span><span class="o">:</span> <span class="nt">Any</span> <span class="nt">triplet</span> <span class="nt">where</span> <span class="nt">i</span> <span class="o">&lt;</span> <span class="nt">j</span> <span class="o">&lt;</span> <span class="nt">k</span> <span class="nt">is</span> <span class="nt">valid</span><span class="o">.</span>
<span class="nt">Example</span> <span class="err">2</span><span class="o">:</span>

<span class="nt">Input</span><span class="o">:</span> <span class="nt">nums</span> <span class="o">=</span> <span class="o">[</span><span class="err">5</span><span class="o">,</span><span class="err">4</span><span class="o">,</span><span class="err">3</span><span class="o">,</span><span class="err">2</span><span class="o">,</span><span class="err">1</span><span class="o">]</span>
<span class="nt">Output</span><span class="o">:</span> <span class="nt">false</span>
<span class="nt">Explanation</span><span class="o">:</span> <span class="nt">No</span> <span class="nt">triplet</span> <span class="nt">exists</span><span class="o">.</span>
<span class="nt">Example</span> <span class="err">3</span><span class="o">:</span>

<span class="nt">Input</span><span class="o">:</span> <span class="nt">nums</span> <span class="o">=</span> <span class="o">[</span><span class="err">2</span><span class="o">,</span><span class="err">1</span><span class="o">,</span><span class="err">5</span><span class="o">,</span><span class="err">0</span><span class="o">,</span><span class="err">4</span><span class="o">,</span><span class="err">6</span><span class="o">]</span>
<span class="nt">Output</span><span class="o">:</span> <span class="nt">true</span>
<span class="nt">Explanation</span><span class="o">:</span> <span class="nt">The</span> <span class="nt">triplet</span> <span class="o">(</span><span class="err">3</span><span class="o">,</span> <span class="err">4</span><span class="o">,</span> <span class="err">5</span><span class="o">)</span> <span class="nt">is</span> <span class="nt">valid</span> <span class="nt">because</span> <span class="nt">nums</span><span class="o">[</span><span class="err">3</span><span class="o">]</span> <span class="o">==</span> <span class="err">0</span> <span class="o">&lt;</span> <span class="nt">nums</span><span class="o">[</span><span class="err">4</span><span class="o">]</span> <span class="o">==</span> <span class="err">4</span> <span class="o">&lt;</span> <span class="nt">nums</span><span class="o">[</span><span class="err">5</span><span class="o">]</span> <span class="o">==</span> <span class="err">6</span><span class="o">.</span>
</code></pre></div></div> <p>Why float(‚Äòinf‚Äô) Fits Here In the Increasing Triplet Subsequence problem:</p> <p>first is initialized to float(‚Äòinf‚Äô) so that it can easily be replaced with the smallest number in the array during the first pass. Similarly, second starts as float(‚Äòinf‚Äô) so it can be updated with the second smallest number after first is identified.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">increasingTriplet</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: bool
        </span><span class="sh">"""</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># Smallest number
</span>        <span class="n">second</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># Second smallest number
</span>        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">num</span>  <span class="c1"># Update smallest
</span>            <span class="k">elif</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">second</span><span class="p">:</span>
                <span class="n">second</span> <span class="o">=</span> <span class="n">num</span>  <span class="c1"># Update second smallest
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we find a number greater than both `first` and `second`,
</span>                <span class="c1"># we have an increasing triplet
</span>                <span class="k">return</span> <span class="bp">True</span>
        
        <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].]]></summary></entry></feed>