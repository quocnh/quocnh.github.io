<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://quocnh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://quocnh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-06T14:10:13+00:00</updated><id>https://quocnh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">53. Maximum Subarray</title><link href="https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray/" rel="alternate" type="text/html" title="53. Maximum Subarray"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray/"><![CDATA[<p>Given an integer array nums, find the subarray with the largest sum, and return its sum.</p> <p>Example 1:</p> <p>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</p> <p>Output: 6</p> <p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p> <p>Example 2:</p> <p>Input: nums = [1]</p> <p>Output: 1</p> <p>Explanation: The subarray [1] has the largest sum 1.</p> <p>Example 3:</p> <p>Input: nums = [5,4,-1,7,8]</p> <p>Output: 23</p> <p>Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.</p> <p>Constraints:</p> <p>1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104</p> <p>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p> <ul> <li>Tutorial about Kananes Algorithm</li> </ul> <p>https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d</p> <h2 id="brute-force">Brute Force</h2> <p>Time: O(n^2)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># total_max = -float('inf')
</span>        <span class="c1"># for i in range(0, len(nums)):
</span>        <span class="c1">#     current_subarray = 0
</span>        <span class="c1">#     for j in range(i, len(nums)):
</span>        <span class="c1">#         current_subarray += nums[j]
</span>        <span class="c1">#         total_max = max(total_max, current_subarray)
</span>        <span class="c1"># return total_max
</span></code></pre></div></div> <h2 id="kadane-algorithm">Kadane Algorithm</h2> <p>Time Complexity: O(n) Space Complexity: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span> <span class="n">Kadanes</span> <span class="n">Algorithm</span><span class="p">:</span> <span class="n">reused</span> <span class="n">the</span> <span class="n">output</span> <span class="n">of</span> <span class="n">smaller</span> <span class="n">subarray</span> <span class="k">for</span> <span class="n">computational</span> <span class="n">efficient</span>
<span class="n">local_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">local_max</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># total_max = -float('inf')
</span>        <span class="c1"># for i in range(0, len(nums)):
</span>        <span class="c1">#     current_subarray = 0
</span>        <span class="c1">#     for j in range(i, len(nums)):
</span>        <span class="c1">#         current_subarray += nums[j]
</span>        <span class="c1">#         total_max = max(total_max, current_subarray)
</span>        <span class="c1"># return total_max
</span>        <span class="n">local_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">global_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">local_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">local_max</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">local_max</span> <span class="o">&gt;</span> <span class="n">global_max</span><span class="p">):</span>
                <span class="n">global_max</span> <span class="o">=</span> <span class="n">local_max</span>
        <span class="k">return</span> <span class="n">global_max</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[Given an integer array nums, find the subarray with the largest sum, and return its sum.]]></summary></entry><entry><title type="html">1207. Unique Number of Occurrences</title><link href="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/" rel="alternate" type="text/html" title="1207. Unique Number of Occurrences"/><published>2024-12-26T00:00:00+00:00</published><updated>2024-12-26T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/"><![CDATA[<p>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.</p> <p>Example 1:</p> <p>Input: arr = [1,2,2,1,1,3]</p> <p>Output: true</p> <p>Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</p> <p>Example 2:</p> <p>Input: arr = [1,2]</p> <p>Output: false</p> <p>Example 3:</p> <p>Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]</p> <p>Output: true</p> <h2 id="set-and-hashmap">set and hashmap</h2> <ul> <li>Time complexity: O(N)</li> <li>Space complexity: O(N),</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uniqueOccurrences</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type arr: List[int]
        :rtype: bool
        </span><span class="sh">"""</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># find number of currences
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Check the same # of currences or not
</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.]]></summary></entry><entry><title type="html">437. Path Sum III</title><link href="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/" rel="alternate" type="text/html" title="437. Path Sum III"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Path%20Sum-III</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p> <p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p> <p>Example 1:</p> <p>Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3</p> <p>Explanation: The paths that sum to 8 are shown. Example 2:</p> <p>Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3</p> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n) , n: number of nodes</li> <li>Space complexity: O(h), h: height of tree</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># # Definition for a binary tree node.
# # class TreeNode(object):
# #     def __init__(self, val=0, left=None, right=None):
# #         self.val = val
# #         self.left = left
# #         self.right = right
# class Solution(object):
#     def pathSum(self, root, targetSum):
#         """
#         :type root: Optional[TreeNode]
#         :type targetSum: int
#         :rtype: int
#         """
#         self.total = 0
#         def helper(node, cur):
#             if not node:
#                 return
</span>            
<span class="c1">#             helper(node.left, cur + node.val)
#             helper(node.right, cur + node.val)
#             if node.val + cur == targetSum:
#                 self.total +=1
#         def dfs(node):
#             if not node:
#                 return
#             count = helper(node, 0)
#             dfs(node.left)
#             dfs(node.right)
</span>            
<span class="c1">#         dfs(root)
#         return self.total
</span>        

<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="c1"># Update the current sum
</span>            <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            
            <span class="c1"># Check if there's a prefix sum such that currentSum - targetSum exists
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span><span class="p">]</span>
            
            <span class="c1"># Update the prefixSums map
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="c1"># Recursively visit left and right subtrees
</span>            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            
            <span class="c1"># Backtrack: remove the currentSum from prefixSums
</span>            <span class="k">if</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Initialize variables
</span>        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use a list to allow mutation
</span>        <span class="n">prefixSums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Base case for when currentSum == targetSum
</span>        
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.]]></summary></entry><entry><title type="html">560. Subarray Sum Equals K</title><link href="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/" rel="alternate" type="text/html" title="560. Subarray Sum Equals K"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">The</span> <span class="n">problem</span> <span class="sh">"</span><span class="s">560. Subarray Sum Equals K</span><span class="sh">"</span> <span class="ow">is</span> <span class="n">about</span> <span class="n">finding</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">a</span> <span class="n">given</span> <span class="n">array</span> <span class="n">whose</span> <span class="n">elements</span> <span class="nb">sum</span> <span class="n">up</span> <span class="n">to</span> <span class="n">a</span> <span class="n">given</span> <span class="n">integer</span> 
<span class="n">𝑘</span>

<span class="n">Understanding</span> <span class="k">with</span> <span class="n">Examples</span>
<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span>

<span class="n">The</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">nums</span> <span class="n">are</span><span class="p">:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="n">There</span> <span class="n">are</span> <span class="mi">2</span> <span class="n">subarrays</span> <span class="n">whose</span> <span class="nb">sum</span> <span class="n">equals</span> 
<span class="n">𝑘</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">runningSum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Initialize with {0: 1}
</span>    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">runningSum</span> <span class="o">+=</span> <span class="n">num</span>
        
        <span class="c1"># Check if (runningSum - k) exists in the hashmap
</span>        <span class="k">if</span> <span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Update the hashmap with the current runningSum
</span>        <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">runningSum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">count</span>   
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python The problem “560. Subarray Sum Equals K” is about finding all the contiguous subarrays of a given array whose elements sum up to a given integer 𝑘]]></summary></entry><entry><title type="html">2130. Maximum Twin Sum of a Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/" rel="alternate" type="text/html" title="2130. Maximum Twin Sum of a Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">n</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">size</span> <span class="n">n</span><span class="p">,</span> <span class="n">where</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">even</span><span class="p">,</span> <span class="n">the</span> <span class="n">ith</span> <span class="nf">node </span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="n">indexed</span><span class="p">)</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">known</span> <span class="k">as</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="nf">the </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="n">th</span> <span class="n">node</span><span class="p">,</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span>

<span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">then</span> <span class="n">node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">and</span> <span class="n">node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mf">2.</span> <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">only</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">4.</span>

<span class="n">The</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="ow">is</span> <span class="n">defined</span> <span class="k">as</span> <span class="n">the</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">its</span> <span class="n">twin</span><span class="p">.</span>

<span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="k">with</span> <span class="n">even</span> <span class="n">length</span><span class="p">,</span> <span class="k">return</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>

 

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">6</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">Nodes</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="n">are</span> <span class="n">the</span> <span class="n">twins</span> <span class="n">of</span> <span class="n">nodes</span> <span class="mi">3</span> <span class="ow">and</span> <span class="mi">2</span><span class="p">,</span> <span class="n">respectively</span><span class="p">.</span> <span class="n">All</span> <span class="n">have</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mf">6.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">no</span> <span class="n">other</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="mf">6.</span> 

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">7</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">The</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="n">present</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">are</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mf">4.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="nf">max</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mf">7.</span> 

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">100000</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">100001</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">There</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">one</span> <span class="n">node</span> <span class="k">with</span> <span class="n">a</span> <span class="n">twin</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">having</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">100000</span> <span class="o">=</span> <span class="mf">100001.</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">even</span> <span class="n">integer</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">105</span><span class="p">].</span>
    <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">105</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <p>Approach:</p> <p>Steps:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find the Middle of the Linked List:
    Use the fast and slow pointer technique to locate the midpoint of the list efficiently.

Reverse the Second Half of the List:
    Reverse the second half of the linked list to facilitate pairing the twin nodes.

Calculate Twin Sums:
    Traverse both halves simultaneously (one from the start and the other from the reversed list) to compute twin sums.

Find the Maximum Twin Sum:
    Keep track of the maximum twin sum encountered during the traversal.
</code></pre></div></div> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pairSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type head: Optional[ListNode]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># find the middle of head
</span>        <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>

        <span class="c1"># reverse the second half
</span>        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">while</span> <span class="n">slow</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">slow</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="c1"># interate 2 linked list and compute sum
</span>        <span class="n">max_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span>
        <span class="k">while</span> <span class="n">second</span><span class="p">:</span>
            <span class="n">max_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">max_sum</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given n a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1.]]></summary></entry><entry><title type="html">206. Reverse Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/" rel="alternate" type="text/html" title="206. Reverse Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">singly</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">,</span> <span class="n">reverse</span> <span class="n">the</span> <span class="nb">list</span><span class="p">,</span> <span class="ow">and</span> <span class="k">return</span> <span class="n">the</span> <span class="nb">reversed</span> <span class="nb">list</span><span class="p">.</span>

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[]</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">].</span>
    <span class="o">-</span><span class="mi">5000</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">5000</span>

 

<span class="n">Follow</span> <span class="n">up</span><span class="p">:</span> <span class="n">A</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">can</span> <span class="n">be</span> <span class="nb">reversed</span> <span class="n">either</span> <span class="n">iteratively</span> <span class="ow">or</span> <span class="n">recursively</span><span class="p">.</span> <span class="n">Could</span> <span class="n">you</span> <span class="n">implement</span> <span class="n">both</span><span class="err">?</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1) <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
      <span class="sh">"""</span><span class="s">
      :type head: Optional[ListNode]
      :rtype: Optional[ListNode]
      </span><span class="sh">"""</span>
      <span class="c1"># 1 -&gt; 2 -&gt; 3 -&gt; 4 - &gt; 5 -&gt; None
</span>      <span class="c1"># Use 2 pointers
</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>

      <span class="k">while</span> <span class="n">current</span><span class="p">:</span> <span class="c1"># while current is still not None
</span>          <span class="c1"># swap the prev and current nodes
</span>          <span class="n">next_node</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
          <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
          <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
          <span class="n">current</span> <span class="o">=</span> <span class="n">next_node</span>
            
      <span class="k">return</span> <span class="n">prev</span> <span class="c1"># new head
</span></code></pre></div> </div> <h2 id="using-stack">Using Stack</h2> </li> </ul>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given the head of a singly linked list, reverse the list, and return the reversed list.]]></summary></entry><entry><title type="html">872. Leaf-Similar Trees</title><link href="https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees/" rel="alternate" type="text/html" title="872. Leaf-Similar Trees"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Leaf-Similar-Trees/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">The</span> <span class="n">problem</span> <span class="sh">"</span><span class="s">872. Leaf-Similar Trees</span><span class="sh">"</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">LeetCode</span> <span class="n">problem</span> <span class="n">that</span> <span class="n">asks</span> <span class="n">you</span> <span class="n">to</span> <span class="n">determine</span> <span class="k">if</span> <span class="n">two</span> <span class="n">binary</span> <span class="n">trees</span> <span class="n">are</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span><span class="p">.</span> <span class="n">Two</span> <span class="n">trees</span> <span class="n">are</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span> <span class="k">if</span> <span class="n">their</span> <span class="n">leaf</span> <span class="n">values</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">when</span> <span class="n">traversed</span> <span class="k">from</span> <span class="n">left</span> <span class="n">to</span> <span class="n">right</span><span class="p">.</span>

<span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">problem</span> <span class="n">breakdown</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">solution</span><span class="p">:</span>

<span class="n">Problem</span> <span class="n">Statement</span>

<span class="n">Consider</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">leaves</span> <span class="n">of</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">tree</span><span class="p">.</span> <span class="n">A</span> <span class="n">leaf</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">node</span> <span class="k">with</span> <span class="n">no</span> <span class="n">children</span><span class="p">.</span> <span class="n">A</span> <span class="n">binary</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">considered</span> <span class="n">leaf</span><span class="o">-</span><span class="n">similar</span> <span class="k">if</span> <span class="n">its</span> <span class="n">leaf</span> <span class="n">values</span><span class="p">,</span> <span class="n">when</span> <span class="n">visited</span> <span class="k">from</span> <span class="n">left</span> <span class="n">to</span> <span class="n">right</span><span class="p">,</span> <span class="n">are</span> <span class="n">identical</span> <span class="n">to</span> <span class="n">another</span> <span class="n">binary</span> <span class="n">tree</span><span class="sh">'</span><span class="s">s leaf values.

Given the roots of two binary trees root1 and root2, return true if and only if the two trees are leaf-similar.

root1 = [3,5,1,6,2,9,8,null,null,7,4]
root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]

return True
</span></code></pre></div></div> <h2 id="dfs">DFS</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(a + b) ```python <h1 id="definition-for-a-binary-tree-node">Definition for a binary tree node.</h1> <h1 id="class-treenodeobject">class TreeNode(object):</h1> <h1 id="def-initself-val0-leftnone-rightnone">def <strong>init</strong>(self, val=0, left=None, right=None):</h1> <h1 id="selfval--val">self.val = val</h1> <h1 id="selfleft--left">self.left = left</h1> <h1 id="selfright--right">self.right = right</h1> <p>class Solution(object): def leafSimilar(self, root1, root2): “”” :type root1: Optional[TreeNode] :type root2: Optional[TreeNode] :rtype: bool “”” # DFS def get_leaf_values(node): if not node: return [] if not node.left and not node.right: return [node.val] return get_leaf_values(node.left) + get_leaf_values(node.right) # Get leaf sequences for both trees leaves1 = get_leaf_values(root1) leaves2 = get_leaf_values(root2)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Compare the sequences
  return leaves1 == leaves2
</code></pre></div> </div> </li> </ul> <p>```</p>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python The problem “872. Leaf-Similar Trees” is a LeetCode problem that asks you to determine if two binary trees are leaf-similar. Two trees are leaf-similar if their leaf values are the same when traversed from left to right.]]></summary></entry><entry><title type="html">136. Single Number</title><link href="https://quocnh.github.io/blog/2024/leetcode-Single-Number/" rel="alternate" type="text/html" title="136. Single Number"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Single-Number</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Single-Number/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integers</span> <span class="n">nums</span><span class="p">,</span> <span class="n">every</span> <span class="n">element</span> <span class="n">appears</span> <span class="n">twice</span> <span class="k">except</span> <span class="k">for</span> <span class="n">one</span><span class="p">.</span> <span class="n">Find</span> <span class="n">that</span> <span class="n">single</span> <span class="n">one</span><span class="p">.</span>

<span class="n">You</span> <span class="n">must</span> <span class="n">implement</span> <span class="n">a</span> <span class="n">solution</span> <span class="k">with</span> <span class="n">a</span> <span class="n">linear</span> <span class="n">runtime</span> <span class="n">complexity</span> <span class="ow">and</span> <span class="n">use</span> <span class="n">only</span> <span class="n">constant</span> <span class="n">extra</span> <span class="n">space</span><span class="p">.</span>

 

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div> <h2 id="bitwise">Bitwise</h2> <ul> <li>Time complexity: O(n)</li> <li> <p>Space complexity: O(1) ```python class Solution(object): def singleNumber(self, nums): “”” :type nums: List[int] :rtype: int “”” result = 0 for i in nums: result ^= i</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  return result 
</code></pre></div> </div> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Explaination
### XOR Operation and Its Properties
The XOR operator (`^`) works at the bit level and follows these rules:

1. **Same bits produce 0:**
   - `0 ^ 0 = 0`
   - `1 ^ 1 = 0`

2. **Different bits produce 1:**
   - `0 ^ 1 = 1`
   - `1 ^ 0 = 1`

3. **Key Properties for This Problem:**
   - `a ^ a = 0` (Self-canceling: XOR of a number with itself is 0.)
   - `a ^ 0 = a` (XOR of a number with 0 is the number itself.)
   - XOR is **commutative** and **associative**, meaning the order of operations doesn't matter.

---

### Example Walkthrough

#### Input:
```plaintext
nums = [4, 1, 2, 1, 2]
</code></pre></div></div> <p>We initialize <code class="language-plaintext highlighter-rouge">result = 0</code> and process each number in the array using XOR. Let’s track the changes step by step, highlighting <strong>where numbers cancel each other out.</strong></p> <hr/> <h4 id="step-by-step-process">Step-by-Step Process</h4> <ol> <li><strong>Initial Value:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 0
</code></pre></div> </div> </li> <li><strong>Step 1:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 0 ^ 4 = 4
</code></pre></div> </div> <ul> <li>No cancellation yet because this is the first number.</li> </ul> </li> <li><strong>Step 2:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 4 ^ 1 = 5
</code></pre></div> </div> <ul> <li>Still no cancellation because <code class="language-plaintext highlighter-rouge">1</code> appears for the first time.</li> </ul> </li> <li><strong>Step 3:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 5 ^ 2 = 7
</code></pre></div> </div> <ul> <li>Still no cancellation because <code class="language-plaintext highlighter-rouge">2</code> appears for the first time.</li> </ul> </li> <li><strong>Step 4:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 7 ^ 1 = 6
</code></pre></div> </div> <ul> <li><strong>Here, <code class="language-plaintext highlighter-rouge">1</code> cancels out!</strong> <ul> <li>Why? Because <code class="language-plaintext highlighter-rouge">1</code> appeared earlier in Step 2.</li> <li>When we XOR the same number (<code class="language-plaintext highlighter-rouge">1 ^ 1</code>), it produces <code class="language-plaintext highlighter-rouge">0</code>, effectively removing <code class="language-plaintext highlighter-rouge">1</code> from the result.</li> <li>Binary operation: <ul> <li><code class="language-plaintext highlighter-rouge">7 (111) ^ 1 (001) = 6 (110)</code></li> </ul> </li> </ul> </li> </ul> </li> <li><strong>Step 5:</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 6 ^ 2 = 4
</code></pre></div> </div> <ul> <li><strong>Here, <code class="language-plaintext highlighter-rouge">2</code> cancels out!</strong> <ul> <li>Why? Because <code class="language-plaintext highlighter-rouge">2</code> appeared earlier in Step 3.</li> <li>When we XOR the same number (<code class="language-plaintext highlighter-rouge">2 ^ 2</code>), it produces <code class="language-plaintext highlighter-rouge">0</code>, effectively removing <code class="language-plaintext highlighter-rouge">2</code> from the result.</li> <li>Binary operation: <ul> <li><code class="language-plaintext highlighter-rouge">6 (110) ^ 2 (010) = 4 (100)</code></li> </ul> </li> </ul> </li> </ul> </li> </ol> <hr/> <h4 id="final-result">Final Result:</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result = 4
</code></pre></div></div> <p>At the end, all duplicate numbers (<code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>) have canceled out, and only the single number <code class="language-plaintext highlighter-rouge">4</code> remains.</p> <hr/> <h3 id="key-takeaways">Key Takeaways</h3> <ol> <li><strong>Where Does Self-Canceling Happen?</strong> <ul> <li><strong>Step 4:</strong> The duplicate <code class="language-plaintext highlighter-rouge">1</code> cancels out (<code class="language-plaintext highlighter-rouge">1 ^ 1 = 0</code>).</li> <li><strong>Step 5:</strong> The duplicate <code class="language-plaintext highlighter-rouge">2</code> cancels out (<code class="language-plaintext highlighter-rouge">2 ^ 2 = 0</code>).</li> </ul> </li> <li><strong>Why XOR Works for This Problem:</strong> <ul> <li>Duplicates cancel out because <code class="language-plaintext highlighter-rouge">a ^ a = 0</code>.</li> <li>The XOR of all numbers leaves only the single number that does not have a duplicate.</li> </ul> </li> </ol> <hr/> <h3 id="code-implementation">Code Implementation</h3> <p>Here is the Python implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">^=</span> <span class="n">num</span>  <span class="c1"># XOR all numbers
</span>        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div> <h4 id="complexity-analysis">Complexity Analysis</h4> <ol> <li><strong>Time Complexity:</strong> <ul> <li>O(N): We iterate through the array once.</li> </ul> </li> <li><strong>Space Complexity:</strong> <ul> <li>O(1): No additional space is used beyond the variable <code class="language-plaintext highlighter-rouge">result</code>.</li> </ul> </li> </ol> <hr/> <h3 id="additional-examples">Additional Examples</h3> <h4 id="example-1">Example 1:</h4> <p><strong>Input:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums = [2, 2, 1]
</code></pre></div></div> <p><strong>Output:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
</code></pre></div></div> <h4 id="example-2">Example 2:</h4> <p><strong>Input:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nums = [4, 1, 2, 1, 2]
</code></pre></div></div> <p><strong>Output:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.]]></summary></entry><entry><title type="html">872. Leaf-Similar Trees</title><link href="https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer/" rel="alternate" type="text/html" title="872. Leaf-Similar Trees"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer/"><![CDATA[<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p> <p>Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000</p> <p>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p> <p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
</code></pre></div></div> <p>Given a roman numeral, convert it to an integer.</p> <p>Example 1:</p> <p>Input: s = “III”</p> <p>Output: 3</p> <p>Explanation: III = 3.</p> <p>Example 2:</p> <p>Input: s = “LVIII”</p> <p>Output: 58</p> <p>Explanation: L = 50, V= 5, III = 3.</p> <p>Example 3:</p> <p>Input: s = “MCMXCIV”</p> <p>Output: 1994</p> <p>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p> <p>Constraints:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 &lt;= s.length &lt;= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].
</code></pre></div></div> <h2 id="hashmap">hashmap</h2> <p>Time: O(n)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">romanToInt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type s: str
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">roman</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">I</span><span class="sh">'</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">V</span><span class="sh">'</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="sh">'</span><span class="s">L</span><span class="sh">'</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span><span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">:</span><span class="mi">1000</span><span class="p">}</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span> 
        <span class="k">return</span> <span class="n">value</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.]]></summary></entry><entry><title type="html">649. Dota2 Senate</title><link href="https://quocnh.github.io/blog/2024/leetcode-dota2-senante/" rel="alternate" type="text/html" title="649. Dota2 Senate"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-dota2-senante</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-dota2-senante/"><![CDATA[<p>The Dota2 Senate problem is a programming challenge that comes from the online coding platform LeetCode. It’s inspired by the mechanics of the game Dota2 but framed in a decision-making scenario with two factions, Radiant and Dire. Here’s a breakdown of the problem:</p> <p>Problem Description: In the Dota2 world, there are two parties, Radiant and Dire, who compete in a senate decision-making process. Each senator has one vote, and they can use it to:</p> <p>Ban one senator from the opposing party. Proceed to the next round. The voting process continues round by round, and at each step:</p> <p>If a senator is banned, they cannot participate in any further rounds. The party that cannot field any senators loses, and the other party wins. The goal is to predict which party will win based on the initial arrangement of senators in the senate.</p> <p>The input is a string representing the initial senate arrangement:</p> <p>‘R’ for Radiant.</p> <p>‘D’ for Dire.</p> <p>Example:</p> <p>Input: “RDD” Output: “Dire”</p> <h2 id="queue">queue</h2> <p>Time: O(n)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">predictPartyVictory</span><span class="p">(</span><span class="n">senate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">radiant</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    <span class="n">dire</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    
    <span class="c1"># Initialize queues with indices of senators
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">senator</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">senate</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">senator</span> <span class="o">==</span> <span class="sh">'</span><span class="s">R</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">radiant</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dire</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># radiant = deque(i for i, ch in enumerate(senate) if ch == "R")
</span>    <span class="c1"># dire = deque(i for i, ch in enumerate(senate) if ch == "D")
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">senate</span><span class="p">)</span>
    
    <span class="c1"># Process the rounds
</span>    <span class="k">while</span> <span class="n">radiant</span> <span class="ow">and</span> <span class="n">dire</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">radiant</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span> <span class="c1"># if dont use deque, use queue, then we can use pop(0)
</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">dire</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        
        <span class="c1"># The senator with the smaller index bans the other
</span>        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">radiant</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># Requeue to vote in the next round
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">dire</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># Requeue to vote in the next round
</span>    
    <span class="k">return</span> <span class="sh">"</span><span class="s">Radiant</span><span class="sh">"</span> <span class="k">if</span> <span class="n">radiant</span> <span class="k">else</span> <span class="sh">"</span><span class="s">Dire</span><span class="sh">"</span>

</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[The Dota2 Senate problem is a programming challenge that comes from the online coding platform LeetCode. It’s inspired by the mechanics of the game Dota2 but framed in a decision-making scenario with two factions, Radiant and Dire. Here’s a breakdown of the problem:]]></summary></entry></feed>