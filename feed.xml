<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://quocnh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://quocnh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-11T03:58:48+00:00</updated><id>https://quocnh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">3412. Find Mirror Score of a String</title><link href="https://quocnh.github.io/blog/2025/leetcode-find-mirror-a-string/" rel="alternate" type="text/html" title="3412. Find Mirror Score of a String"/><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2025/leetcode-find-mirror-a-string</id><content type="html" xml:base="https://quocnh.github.io/blog/2025/leetcode-find-mirror-a-string/"><![CDATA[<p>You are given a string s.</p> <p>We define the mirror of a letter in the English alphabet as its corresponding letter when the alphabet is reversed. For example, the mirror of ‘a’ is ‘z’, and the mirror of ‘y’ is ‘b’.</p> <p>Initially, all characters in the string s are unmarked.</p> <p>You start with a score of 0, and you perform the following process on the string s:</p> <p>Iterate through the string from left to right. At each index i, find the closest unmarked index j such that j &lt; i and s[j] is the mirror of s[i]. Then, mark both indices i and j, and add the value i - j to the total score. If no such index j exists for the index i, move on to the next index without making any changes. Return the total score at the end of the process.</p> <p>Example 1:</p> <p>Input: s = “aczzx”</p> <p>Output: 5</p> <p>Explanation:</p> <p>i = 0. There is no index j that satisfies the conditions, so we skip. i = 1. There is no index j that satisfies the conditions, so we skip. i = 2. The closest index j that satisfies the conditions is j = 0, so we mark both indices 0 and 2, and then add 2 - 0 = 2 to the score. i = 3. There is no index j that satisfies the conditions, so we skip. i = 4. The closest index j that satisfies the conditions is j = 1, so we mark both indices 1 and 4, and then add 4 - 1 = 3 to the score.</p> <h2 id="brute-force">brute force</h2> <h2 id="instructions">instructions:</h2> <h1 id="-brute-force-explanation">✅ <strong>Brute Force Explanation:</strong></h1> <h3 id="process"><strong>Process:</strong></h3> <ul> <li><strong>Initialize:</strong> <code class="language-plaintext highlighter-rouge">score = 0</code>, <code class="language-plaintext highlighter-rouge">marked = [False, False, False, False, False]</code></li> </ul> <h3 id="step-by-step"><strong>Step by Step:</strong></h3> <ul> <li><strong>i = 0</strong> → Character <code class="language-plaintext highlighter-rouge">'a'</code> <ul> <li>No previous unmarked mirror → skip.</li> </ul> </li> <li><strong>i = 1</strong> → Character <code class="language-plaintext highlighter-rouge">'c'</code> <ul> <li>No previous unmarked mirror → skip.</li> </ul> </li> <li><strong>i = 2</strong> → Character <code class="language-plaintext highlighter-rouge">'z'</code> <ul> <li>Closest unmarked mirror: <ul> <li><code class="language-plaintext highlighter-rouge">'a'</code> at index <code class="language-plaintext highlighter-rouge">0</code> is the mirror of <code class="language-plaintext highlighter-rouge">'z'</code>.</li> <li>Mark both <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">2</code>.</li> <li><strong>Score += (2 - 0) = 2</strong></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">marked = [True, False, True, False, False]</code></li> </ul> </li> <li><strong>i = 3</strong> → Character <code class="language-plaintext highlighter-rouge">'z'</code> <ul> <li>No previous unmarked mirror → skip.</li> </ul> </li> <li><strong>i = 4</strong> → Character <code class="language-plaintext highlighter-rouge">'x'</code> <ul> <li>Closest unmarked mirror: <ul> <li><code class="language-plaintext highlighter-rouge">'c'</code> at index <code class="language-plaintext highlighter-rouge">1</code> is the mirror of <code class="language-plaintext highlighter-rouge">'x'</code>.</li> <li>Mark both <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">4</code>.</li> <li><strong>Score += (4 - 1) = 3</strong></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">marked = [True, True, True, False, True]</code></li> </ul> </li> </ul> <h3 id="final-score"><strong>Final Score:</strong></h3> <ul> <li><strong>2 + 3 = 5</strong></li> </ul> <hr/> <hr/> <h1 id="-stack-based-optimized-approach">✅ <strong>Stack-Based Optimized Approach:</strong></h1> <h3 id="process-1"><strong>Process:</strong></h3> <ul> <li>Use a <strong>stack (dictionary)</strong> to track unmarked characters.</li> <li>If a mirror is found, calculate the score and remove it from the stack.</li> </ul> <hr/> <h3 id="step-by-step-1"><strong>Step by Step:</strong></h3> <ul> <li><strong>Initialize:</strong> <code class="language-plaintext highlighter-rouge">score = 0</code>, <code class="language-plaintext highlighter-rouge">stack = {}</code></li> </ul> <h3 id="step-1-a"><strong>Step 1:</strong> <code class="language-plaintext highlighter-rouge">'a'</code></h3> <ul> <li>Mirror = <code class="language-plaintext highlighter-rouge">'z'</code>.</li> <li>No mirror <code class="language-plaintext highlighter-rouge">'z'</code> in the stack.</li> <li>Add <code class="language-plaintext highlighter-rouge">'a'</code> to stack: <ul> <li><code class="language-plaintext highlighter-rouge">stack = {'a': [0]}</code></li> </ul> </li> </ul> <hr/> <h3 id="step-2-c"><strong>Step 2:</strong> <code class="language-plaintext highlighter-rouge">'c'</code></h3> <ul> <li>Mirror = <code class="language-plaintext highlighter-rouge">'x'</code>.</li> <li>No mirror <code class="language-plaintext highlighter-rouge">'x'</code> in the stack.</li> <li>Add <code class="language-plaintext highlighter-rouge">'c'</code> to stack: <ul> <li><code class="language-plaintext highlighter-rouge">stack = {'a': [0], 'c': [1]}</code></li> </ul> </li> </ul> <hr/> <h3 id="step-3-z"><strong>Step 3:</strong> <code class="language-plaintext highlighter-rouge">'z'</code></h3> <ul> <li>Mirror = <code class="language-plaintext highlighter-rouge">'a'</code>.</li> <li>Mirror <code class="language-plaintext highlighter-rouge">'a'</code> exists in stack at index <code class="language-plaintext highlighter-rouge">0</code>.</li> <li><strong>Score += (2 - 0) = 2</strong></li> <li>Remove <code class="language-plaintext highlighter-rouge">0</code> from stack. <ul> <li><code class="language-plaintext highlighter-rouge">stack = {'c': [1]}</code></li> </ul> </li> </ul> <hr/> <h3 id="step-4-z"><strong>Step 4:</strong> <code class="language-plaintext highlighter-rouge">'z'</code></h3> <ul> <li>Mirror = <code class="language-plaintext highlighter-rouge">'a'</code>.</li> <li>No unmarked <code class="language-plaintext highlighter-rouge">'a'</code> left.</li> <li>Add <code class="language-plaintext highlighter-rouge">'z'</code> to stack. <ul> <li><code class="language-plaintext highlighter-rouge">stack = {'c': [1], 'z': [3]}</code></li> </ul> </li> </ul> <hr/> <h3 id="step-5-x"><strong>Step 5:</strong> <code class="language-plaintext highlighter-rouge">'x'</code></h3> <ul> <li>Mirror = <code class="language-plaintext highlighter-rouge">'c'</code>.</li> <li>Mirror <code class="language-plaintext highlighter-rouge">'c'</code> exists in stack at index <code class="language-plaintext highlighter-rouge">1</code>.</li> <li><strong>Score += (4 - 1) = 3</strong></li> <li>Remove <code class="language-plaintext highlighter-rouge">1</code> from stack. <ul> <li><code class="language-plaintext highlighter-rouge">stack = {'z': [3]}</code></li> </ul> </li> </ul> <hr/> <h3 id="final-score-1"><strong>Final Score:</strong></h3> <ul> <li><strong>2 + 3 = 5</strong></li> </ul> <hr/> <h1 id="-final-answer">✅ <strong>Final Answer:</strong></h1> <p>Both <strong>Brute Force</strong> and <strong>Stack-Based</strong> approaches return the <strong>correct score of 5</strong>.</p> <h3 id="key-takeaways"><strong>Key Takeaways:</strong></h3> <ul> <li>The <strong>brute force</strong> checks all previous unmarked characters, so it is slower (<code class="language-plaintext highlighter-rouge">O(n^2)</code>).</li> <li>The <strong>stack-based</strong> approach tracks only the unmarked characters efficiently, achieving <code class="language-plaintext highlighter-rouge">O(n)</code> time complexity.</li> </ul> <hr/> <h2 id="code">code:</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># copy your solution here
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">calculateScore</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type s: str
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># brute force
</span>        <span class="c1">#Brute Force Approach:
</span>        <span class="c1">#Steps:
</span>        
        <span class="c1">#Traverse through the string.
</span>        <span class="c1">#For each character s[i], find the closest unmarked index j.
</span>        <span class="c1">#If a match is found, mark both and update the score.
</span>
        <span class="k">def</span> <span class="nf">get_mirror</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">chr</span><span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>  <span class="c1"># To keep track of marked indices
</span>        <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">mirror_char</span> <span class="o">=</span> <span class="nf">get_mirror</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Search for the closest unmarked j &lt; i
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">marked</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">mirror_char</span><span class="p">:</span>
                    <span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">marked</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">score</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span>
                    <span class="k">break</span>  <span class="c1"># Stop after finding the closest match
</span>
        <span class="k">return</span> <span class="n">score</span>

        <span class="c1"># def get_mirror(char):
</span>        <span class="c1"># # Returns the mirror character based on the reverse alphabet mapping
</span>        <span class="c1">#     return chr(ord('z') - (ord(char) - ord('a')))
</span>    
        <span class="c1"># score = 0
</span>        <span class="c1"># stack = {}  # Dictionary with lists to store unmarked characters' indices
</span>
        <span class="c1"># for i, char in enumerate(s):
</span>        <span class="c1">#     mirror_char = get_mirror(char)
</span>            
        <span class="c1">#     # If a mirror character exists in the stack, use the closest (last added) one
</span>        <span class="c1">#     if mirror_char in stack and stack[mirror_char]:
</span>        <span class="c1">#         j = stack[mirror_char].pop()  # Get the closest match
</span>        <span class="c1">#         score += i - j
</span>        <span class="c1">#     else:
</span>        <span class="c1">#         # If no mirror is available, store the current index for future matching
</span>        <span class="c1">#         if char not in stack:
</span>        <span class="c1">#             stack[char] = []
</span>        <span class="c1">#         stack[char].append(i)
</span>
        <span class="c1"># return score
</span></code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[You are given a string s.]]></summary></entry><entry><title type="html">3411. Maximum Subarray With Equal Products</title><link href="https://quocnh.github.io/blog/2025/leetcode-maximum-subarray-with-equal-products/" rel="alternate" type="text/html" title="3411. Maximum Subarray With Equal Products"/><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2025/leetcode-maximum-subarray-with-equal-products</id><content type="html" xml:base="https://quocnh.github.io/blog/2025/leetcode-maximum-subarray-with-equal-products/"><![CDATA[<p>You are given an array of positive integers nums.</p> <p>An array arr is called product equivalent if prod(arr) == lcm(arr) * gcd(arr), where:</p> <p>prod(arr) is the product of all elements of arr. gcd(arr) is the GCD of all elements of arr. lcm(arr) is the LCM of all elements of arr.</p> <p>Return the length of the longest product equivalent subarray of nums.</p> <p>A subarray is a contiguous non-empty sequence of elements within an array.</p> <p>The term gcd(a, b) denotes the greatest common divisor of a and b.</p> <p>The term lcm(a, b) denotes the least common multiple of a and b.</p> <p>Example 1:</p> <p>Input: nums = [1,2,1,2,1,1,1]</p> <p>Output: 5</p> <p>Explanation:</p> <p>The longest product equivalent subarray is [1, 2, 1, 1, 1], where prod([1, 2, 1, 1, 1]) = 2, gcd([1, 2, 1, 1, 1]) = 1, and lcm([1, 2, 1, 1, 1]) = 2.</p> <p>Example 2:</p> <p>Input: nums = [2,3,4,5,6]</p> <p>Output: 3</p> <p>Explanation:</p> <p>The longest product equivalent subarray is [3, 4, 5].</p> <p>Example 3:</p> <p>Input: nums = [1,2,3,1,4,5,1]</p> <p>Output: 5</p> <h2 id="brute-force">brute force</h2> <p>Time: O(n^2)</p> <p>Space: O(1)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="c1"># Function to calculate the GCD of two numbers
</span>    <span class="k">def</span> <span class="nf">compute_gcd</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">a</span>
    
    <span class="c1"># Function to calculate the GCD of a list
</span>    <span class="k">def</span> <span class="nf">gcd_of_list</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_gcd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># Function to calculate the LCM of two numbers
</span>    <span class="k">def</span> <span class="nf">compute_lcm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">//</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    
    <span class="c1"># Function to calculate the LCM of a list
</span>    <span class="k">def</span> <span class="nf">lcm_of_list</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">compute_lcm</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>  <span class="c1"># Fixed 'self.result' -&gt; 'result'
</span>        <span class="k">return</span> <span class="n">result</span>
    
    <span class="c1"># Function to calculate the product of a list
</span>    <span class="k">def</span> <span class="nf">product_of_list</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">*=</span> <span class="n">num</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">maxLength</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Try every subarray starting at index i and ending at index j
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">subarray</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">product</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">product_of_list</span><span class="p">(</span><span class="n">subarray</span><span class="p">)</span>
                <span class="n">gcd_value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">gcd_of_list</span><span class="p">(</span><span class="n">subarray</span><span class="p">)</span>
                <span class="n">lcm_value</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">lcm_of_list</span><span class="p">(</span><span class="n">subarray</span><span class="p">)</span>
                
                <span class="c1"># Check if the condition holds
</span>                <span class="k">if</span> <span class="n">product</span> <span class="o">==</span> <span class="n">lcm_value</span> <span class="o">*</span> <span class="n">gcd_value</span><span class="p">:</span>
                    <span class="n">max_length</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">max_length</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[You are given an array of positive integers nums.]]></summary></entry><entry><title type="html">649. Dota2 Senate</title><link href="https://quocnh.github.io/blog/2025/leetcode-dota2-senante/" rel="alternate" type="text/html" title="649. Dota2 Senate"/><published>2025-01-02T00:00:00+00:00</published><updated>2025-01-02T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2025/leetcode-dota2-senante</id><content type="html" xml:base="https://quocnh.github.io/blog/2025/leetcode-dota2-senante/"><![CDATA[<p>The Dota2 Senate problem is a programming challenge that comes from the online coding platform LeetCode. It’s inspired by the mechanics of the game Dota2 but framed in a decision-making scenario with two factions, Radiant and Dire. Here’s a breakdown of the problem:</p> <p>Problem Description: In the Dota2 world, there are two parties, Radiant and Dire, who compete in a senate decision-making process. Each senator has one vote, and they can use it to:</p> <p>Ban one senator from the opposing party. Proceed to the next round. The voting process continues round by round, and at each step:</p> <p>If a senator is banned, they cannot participate in any further rounds. The party that cannot field any senators loses, and the other party wins. The goal is to predict which party will win based on the initial arrangement of senators in the senate.</p> <p>The input is a string representing the initial senate arrangement:</p> <p>‘R’ for Radiant.</p> <p>‘D’ for Dire.</p> <p>Example:</p> <p>Input: “RDD” Output: “Dire”</p> <h2 id="queue">queue</h2> <p>Time: O(n)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">predictPartyVictory</span><span class="p">(</span><span class="n">senate</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">radiant</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    <span class="n">dire</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    
    <span class="c1"># Initialize queues with indices of senators
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">senator</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">senate</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">senator</span> <span class="o">==</span> <span class="sh">'</span><span class="s">R</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">radiant</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dire</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># radiant = deque(i for i, ch in enumerate(senate) if ch == "R")
</span>    <span class="c1"># dire = deque(i for i, ch in enumerate(senate) if ch == "D")
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">senate</span><span class="p">)</span>
    
    <span class="c1"># Process the rounds
</span>    <span class="k">while</span> <span class="n">radiant</span> <span class="ow">and</span> <span class="n">dire</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">radiant</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span> <span class="c1"># if dont use deque, use queue, then we can use pop(0)
</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">dire</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        
        <span class="c1"># The senator with the smaller index bans the other
</span>        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">radiant</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># Requeue to vote in the next round
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">dire</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># Requeue to vote in the next round
</span>    
    <span class="k">return</span> <span class="sh">"</span><span class="s">Radiant</span><span class="sh">"</span> <span class="k">if</span> <span class="n">radiant</span> <span class="k">else</span> <span class="sh">"</span><span class="s">Dire</span><span class="sh">"</span>

</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[The Dota2 Senate problem is a programming challenge that comes from the online coding platform LeetCode. It’s inspired by the mechanics of the game Dota2 but framed in a decision-making scenario with two factions, Radiant and Dire. Here’s a breakdown of the problem:]]></summary></entry><entry><title type="html">53. Maximum Subarray</title><link href="https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray/" rel="alternate" type="text/html" title="53. Maximum Subarray"/><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Maximum-Subarray/"><![CDATA[<p>Given an integer array nums, find the subarray with the largest sum, and return its sum.</p> <p>Example 1:</p> <p>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</p> <p>Output: 6</p> <p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p> <p>Example 2:</p> <p>Input: nums = [1]</p> <p>Output: 1</p> <p>Explanation: The subarray [1] has the largest sum 1.</p> <p>Example 3:</p> <p>Input: nums = [5,4,-1,7,8]</p> <p>Output: 23</p> <p>Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.</p> <p>Constraints:</p> <p>1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104</p> <p>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p> <ul> <li>Tutorial about Kananes Algorithm</li> </ul> <p>https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d</p> <h2 id="brute-force">Brute Force</h2> <p>Time: O(n^2)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># total_max = -float('inf')
</span>        <span class="c1"># for i in range(0, len(nums)):
</span>        <span class="c1">#     current_subarray = 0
</span>        <span class="c1">#     for j in range(i, len(nums)):
</span>        <span class="c1">#         current_subarray += nums[j]
</span>        <span class="c1">#         total_max = max(total_max, current_subarray)
</span>        <span class="c1"># return total_max
</span></code></pre></div></div> <h2 id="kadane-algorithm">Kadane Algorithm</h2> <p>Time Complexity: O(n) Space Complexity: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span> <span class="n">Kadanes</span> <span class="n">Algorithm</span><span class="p">:</span> <span class="n">reused</span> <span class="n">the</span> <span class="n">output</span> <span class="n">of</span> <span class="n">smaller</span> <span class="n">subarray</span> <span class="k">for</span> <span class="n">computational</span> <span class="n">efficient</span>
<span class="n">local_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">local_max</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type nums: List[int]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># total_max = -float('inf')
</span>        <span class="c1"># for i in range(0, len(nums)):
</span>        <span class="c1">#     current_subarray = 0
</span>        <span class="c1">#     for j in range(i, len(nums)):
</span>        <span class="c1">#         current_subarray += nums[j]
</span>        <span class="c1">#         total_max = max(total_max, current_subarray)
</span>        <span class="c1"># return total_max
</span>        <span class="n">local_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">global_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">local_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">local_max</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">local_max</span> <span class="o">&gt;</span> <span class="n">global_max</span><span class="p">):</span>
                <span class="n">global_max</span> <span class="o">=</span> <span class="n">local_max</span>
        <span class="k">return</span> <span class="n">global_max</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[Given an integer array nums, find the subarray with the largest sum, and return its sum.]]></summary></entry><entry><title type="html">872. Leaf-Similar Trees</title><link href="https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer/" rel="alternate" type="text/html" title="872. Leaf-Similar Trees"/><published>2024-12-26T00:00:00+00:00</published><updated>2024-12-26T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Roman-to-Integer/"><![CDATA[<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p> <p>Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000</p> <p>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p> <p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
</code></pre></div></div> <p>Given a roman numeral, convert it to an integer.</p> <p>Example 1:</p> <p>Input: s = “III”</p> <p>Output: 3</p> <p>Explanation: III = 3.</p> <p>Example 2:</p> <p>Input: s = “LVIII”</p> <p>Output: 58</p> <p>Explanation: L = 50, V= 5, III = 3.</p> <p>Example 3:</p> <p>Input: s = “MCMXCIV”</p> <p>Output: 1994</p> <p>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p> <p>Constraints:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 &lt;= s.length &lt;= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].
</code></pre></div></div> <h2 id="hashmap">hashmap</h2> <p>Time: O(n)</p> <p>Space: O(n)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">romanToInt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type s: str
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">roman</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">I</span><span class="sh">'</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">V</span><span class="sh">'</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="sh">'</span><span class="s">X</span><span class="sh">'</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="sh">'</span><span class="s">L</span><span class="sh">'</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span><span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">:</span><span class="mi">1000</span><span class="p">}</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">roman</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span> 
        <span class="k">return</span> <span class="n">value</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode,"/><category term="apple"/><summary type="html"><![CDATA[Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.]]></summary></entry><entry><title type="html">1207. Unique Number of Occurrences</title><link href="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/" rel="alternate" type="text/html" title="1207. Unique Number of Occurrences"/><published>2024-12-26T00:00:00+00:00</published><updated>2024-12-26T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Unique-Number-of-Occurrences/"><![CDATA[<p>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.</p> <p>Example 1:</p> <p>Input: arr = [1,2,2,1,1,3]</p> <p>Output: true</p> <p>Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</p> <p>Example 2:</p> <p>Input: arr = [1,2]</p> <p>Output: false</p> <p>Example 3:</p> <p>Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]</p> <p>Output: true</p> <h2 id="set-and-hashmap">set and hashmap</h2> <ul> <li>Time complexity: O(N)</li> <li>Space complexity: O(N),</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uniqueOccurrences</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type arr: List[int]
        :rtype: bool
        </span><span class="sh">"""</span>
        <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># find number of currences
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">hashmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Check the same # of currences or not
</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">hashmap</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.]]></summary></entry><entry><title type="html">437. Path Sum III</title><link href="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/" rel="alternate" type="text/html" title="437. Path Sum III"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Path%20Sum-III</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Path-Sum-III/"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p> <p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p> <p>Example 1:</p> <p>Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3</p> <p>Explanation: The paths that sum to 8 are shown. Example 2:</p> <p>Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3</p> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n) , n: number of nodes</li> <li>Space complexity: O(h), h: height of tree</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># # Definition for a binary tree node.
# # class TreeNode(object):
# #     def __init__(self, val=0, left=None, right=None):
# #         self.val = val
# #         self.left = left
# #         self.right = right
# class Solution(object):
#     def pathSum(self, root, targetSum):
#         """
#         :type root: Optional[TreeNode]
#         :type targetSum: int
#         :rtype: int
#         """
#         self.total = 0
#         def helper(node, cur):
#             if not node:
#                 return
</span>            
<span class="c1">#             helper(node.left, cur + node.val)
#             helper(node.right, cur + node.val)
#             if node.val + cur == targetSum:
#                 self.total +=1
#         def dfs(node):
#             if not node:
#                 return
#             count = helper(node, 0)
#             dfs(node.left)
#             dfs(node.right)
</span>            
<span class="c1">#         dfs(root)
#         return self.total
</span>        

<span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pathSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="c1"># Update the current sum
</span>            <span class="n">currentSum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            
            <span class="c1"># Check if there's a prefix sum such that currentSum - targetSum exists
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span> <span class="o">-</span> <span class="n">targetSum</span><span class="p">]</span>
            
            <span class="c1"># Update the prefixSums map
</span>            <span class="k">if</span> <span class="n">currentSum</span> <span class="ow">in</span> <span class="n">prefixSums</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="c1"># Recursively visit left and right subtrees
</span>            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">currentSum</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            
            <span class="c1"># Backtrack: remove the currentSum from prefixSums
</span>            <span class="k">if</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixSums</span><span class="p">[</span><span class="n">currentSum</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Initialize variables
</span>        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use a list to allow mutation
</span>        <span class="n">prefixSums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Base case for when currentSum == targetSum
</span>        
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prefixSums</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.]]></summary></entry><entry><title type="html">560. Subarray Sum Equals K</title><link href="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/" rel="alternate" type="text/html" title="560. Subarray Sum Equals K"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Subarray-Sum-Equals-K/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">The</span> <span class="n">problem</span> <span class="sh">"</span><span class="s">560. Subarray Sum Equals K</span><span class="sh">"</span> <span class="ow">is</span> <span class="n">about</span> <span class="n">finding</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">a</span> <span class="n">given</span> <span class="n">array</span> <span class="n">whose</span> <span class="n">elements</span> <span class="nb">sum</span> <span class="n">up</span> <span class="n">to</span> <span class="n">a</span> <span class="n">given</span> <span class="n">integer</span> 
<span class="n">𝑘</span>

<span class="n">Understanding</span> <span class="k">with</span> <span class="n">Examples</span>
<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">Input</span><span class="p">:</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span>

<span class="n">The</span> <span class="n">contiguous</span> <span class="n">subarrays</span> <span class="n">of</span> <span class="n">nums</span> <span class="n">are</span><span class="p">:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="err">→</span> <span class="n">Sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span>
<span class="n">There</span> <span class="n">are</span> <span class="mi">2</span> <span class="n">subarrays</span> <span class="n">whose</span> <span class="nb">sum</span> <span class="n">equals</span> 
<span class="n">𝑘</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div> <h2 id="prifix-sum">Prifix Sum</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">runningSum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hashmap</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1"># Initialize with {0: 1}
</span>    
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">runningSum</span> <span class="o">+=</span> <span class="n">num</span>
        
        <span class="c1"># Check if (runningSum - k) exists in the hashmap
</span>        <span class="k">if</span> <span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hashmap</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
        
        <span class="c1"># Update the hashmap with the current runningSum
</span>        <span class="n">hashmap</span><span class="p">[</span><span class="n">runningSum</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashmap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">runningSum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">count</span>   
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python The problem “560. Subarray Sum Equals K” is about finding all the contiguous subarrays of a given array whose elements sum up to a given integer 𝑘]]></summary></entry><entry><title type="html">2130. Maximum Twin Sum of a Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/" rel="alternate" type="text/html" title="2130. Maximum Twin Sum of a Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Maximum-Twin-Sum-of-a-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">n</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">size</span> <span class="n">n</span><span class="p">,</span> <span class="n">where</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">even</span><span class="p">,</span> <span class="n">the</span> <span class="n">ith</span> <span class="nf">node </span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="n">indexed</span><span class="p">)</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">known</span> <span class="k">as</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="nf">the </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="n">th</span> <span class="n">node</span><span class="p">,</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span>

<span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">then</span> <span class="n">node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">and</span> <span class="n">node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mf">2.</span> <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">only</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="k">for</span> <span class="n">n</span> <span class="o">=</span> <span class="mf">4.</span>

<span class="n">The</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="ow">is</span> <span class="n">defined</span> <span class="k">as</span> <span class="n">the</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">its</span> <span class="n">twin</span><span class="p">.</span>

<span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">linked</span> <span class="nb">list</span> <span class="k">with</span> <span class="n">even</span> <span class="n">length</span><span class="p">,</span> <span class="k">return</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>

 

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">6</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">Nodes</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span> <span class="n">are</span> <span class="n">the</span> <span class="n">twins</span> <span class="n">of</span> <span class="n">nodes</span> <span class="mi">3</span> <span class="ow">and</span> <span class="mi">2</span><span class="p">,</span> <span class="n">respectively</span><span class="p">.</span> <span class="n">All</span> <span class="n">have</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mf">6.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">no</span> <span class="n">other</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="mf">6.</span> 

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">7</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">The</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">twins</span> <span class="n">present</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">are</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">3</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="o">-</span> <span class="n">Node</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">twin</span> <span class="n">of</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">having</span> <span class="n">a</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mf">4.</span>
<span class="n">Thus</span><span class="p">,</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="ow">is</span> <span class="nf">max</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mf">7.</span> 

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">100000</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">100001</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">There</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">one</span> <span class="n">node</span> <span class="k">with</span> <span class="n">a</span> <span class="n">twin</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">having</span> <span class="n">twin</span> <span class="nb">sum</span> <span class="n">of</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">100000</span> <span class="o">=</span> <span class="mf">100001.</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">even</span> <span class="n">integer</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">105</span><span class="p">].</span>
    <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">105</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <p>Approach:</p> <p>Steps:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find the Middle of the Linked List:
    Use the fast and slow pointer technique to locate the midpoint of the list efficiently.

Reverse the Second Half of the List:
    Reverse the second half of the linked list to facilitate pairing the twin nodes.

Calculate Twin Sums:
    Traverse both halves simultaneously (one from the start and the other from the reversed list) to compute twin sums.

Find the Maximum Twin Sum:
    Keep track of the maximum twin sum encountered during the traversal.
</code></pre></div></div> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pairSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type head: Optional[ListNode]
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="c1"># find the middle of head
</span>        <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>

        <span class="c1"># reverse the second half
</span>        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">while</span> <span class="n">slow</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">slow</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="c1"># interate 2 linked list and compute sum
</span>        <span class="n">max_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">prev</span>
        <span class="k">while</span> <span class="n">second</span><span class="p">:</span>
            <span class="n">max_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">max_sum</span>
        
</code></pre></div></div>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given n a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1.]]></summary></entry><entry><title type="html">206. Reverse Linked List</title><link href="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/" rel="alternate" type="text/html" title="206. Reverse Linked List"/><published>2024-12-14T00:00:00+00:00</published><updated>2024-12-14T00:00:00+00:00</updated><id>https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List</id><content type="html" xml:base="https://quocnh.github.io/blog/2024/leetcode-Reverse-Linked-List/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Given</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">a</span> <span class="n">singly</span> <span class="n">linked</span> <span class="nb">list</span><span class="p">,</span> <span class="n">reverse</span> <span class="n">the</span> <span class="nb">list</span><span class="p">,</span> <span class="ow">and</span> <span class="k">return</span> <span class="n">the</span> <span class="nb">reversed</span> <span class="nb">list</span><span class="p">.</span>

<span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Example</span> <span class="mi">3</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[]</span>

 

<span class="n">Constraints</span><span class="p">:</span>

    <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">range</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">].</span>
    <span class="o">-</span><span class="mi">5000</span> <span class="o">&lt;=</span> <span class="n">Node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">5000</span>

 

<span class="n">Follow</span> <span class="n">up</span><span class="p">:</span> <span class="n">A</span> <span class="n">linked</span> <span class="nb">list</span> <span class="n">can</span> <span class="n">be</span> <span class="nb">reversed</span> <span class="n">either</span> <span class="n">iteratively</span> <span class="ow">or</span> <span class="n">recursively</span><span class="p">.</span> <span class="n">Could</span> <span class="n">you</span> <span class="n">implement</span> <span class="n">both</span><span class="err">?</span>

</code></pre></div></div> <h2 id="two-pointers">Two Pointers</h2> <ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1) <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
      <span class="sh">"""</span><span class="s">
      :type head: Optional[ListNode]
      :rtype: Optional[ListNode]
      </span><span class="sh">"""</span>
      <span class="c1"># 1 -&gt; 2 -&gt; 3 -&gt; 4 - &gt; 5 -&gt; None
</span>      <span class="c1"># Use 2 pointers
</span>
      <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>

      <span class="k">while</span> <span class="n">current</span><span class="p">:</span> <span class="c1"># while current is still not None
</span>          <span class="c1"># swap the prev and current nodes
</span>          <span class="n">next_node</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="nb">next</span>
          <span class="n">current</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prev</span>
          <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
          <span class="n">current</span> <span class="o">=</span> <span class="n">next_node</span>
            
      <span class="k">return</span> <span class="n">prev</span> <span class="c1"># new head
</span></code></pre></div> </div> <h2 id="using-stack">Using Stack</h2> </li> </ul>]]></content><author><name>Quoc Nguyen</name></author><category term="leetcode"/><summary type="html"><![CDATA[```python Given the head of a singly linked list, reverse the list, and return the reversed list.]]></summary></entry></feed>